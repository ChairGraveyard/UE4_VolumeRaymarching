#pragma once

float RemapIntensity(float intensity, float2 TFIntensityDomain)
{
    return clamp((intensity - TFIntensityDomain.x) / (TFIntensityDomain.y - TFIntensityDomain.x), 0, 1);
}

void RemoveAndAddColor(int3 pos, float4 removedColor, float4 addedColor, float4 oldColor,
RWTexture3D<float> RLightVolume, RWTexture3D<float> GLightVolume, RWTexture3D<float> BLightVolume, RWTexture3D<float> ALightVolume)
{
	// Substract "removed" alpha from original alpha
    float currentAlpha = oldColor.a - removedColor.a;
	// Get current weight of color components relative to old alpha.
    float currentRed = oldColor.r * oldColor.a;
    float currentGreen = oldColor.g * oldColor.a;
    float currentBlue = oldColor.b * oldColor.a;

	// Get the weights of colors after removing the removed color (these are already relative to the currentAlpha)
    // As in - if they are now (0.1, 0.1, 0.1, 0.1), it is actually full white at 0.1 intensity
    float afterRemoveRed = currentRed - (removedColor.r * removedColor.a);
    float afterRemoveGreen = currentGreen - (removedColor.g * removedColor.a);
    float afterRemoveBlue = currentBlue - (removedColor.b * removedColor.a);

	// Now we have subtracted the color. Start adding the added one.
    currentAlpha = currentAlpha + addedColor.a;

	// We can assume currentAlpha will be nonzero now, as otherwise we'd be adding a 0 intensity light
	// (Actually, TODO add a check to C code to return on lights with 0 intensity)...
    ALightVolume[pos] = currentAlpha;
    RLightVolume[pos] = (afterRemoveRed + (addedColor.r * addedColor.a)) / currentAlpha;
    GLightVolume[pos] = (afterRemoveGreen + (addedColor.g * addedColor.a)) / currentAlpha;
    BLightVolume[pos] = (afterRemoveBlue + (addedColor.b * addedColor.a)) / currentAlpha;

	// TODO
	//
	// Optimize this!
}

void AddColor(int3 pos, float4 addedColor, float4 oldColor, 
RWTexture3D<float> RLightVolume, RWTexture3D<float> GLightVolume, RWTexture3D<float> BLightVolume, RWTexture3D<float> ALightVolume)
{
    float totalAlpha = oldColor.a + addedColor.a;

    float currentRed   = oldColor.r * oldColor.a;
    float currentGreen = oldColor.g * oldColor.a;
    float currentBlue  = oldColor.b * oldColor.a;

	ALightVolume[pos] = totalAlpha;

    if (totalAlpha == 0)
    {
		// Division by zero is baaaad, mmkey?
		// Don't need to set the other colors - since alpha is zero, currentXXX will always equal zero on next add anyways.
        return;
    }

    RLightVolume[pos] = (currentRed   + (addedColor.r * addedColor.a)) / totalAlpha;
    GLightVolume[pos] = (currentGreen + (addedColor.g * addedColor.a)) / totalAlpha;
    BLightVolume[pos] = (currentBlue  + (addedColor.b * addedColor.a)) / totalAlpha;
    // Todo? LERP instead of explicit?
}


float4 GetColor(int3 pos, RWTexture3D<float> RLightVolume, RWTexture3D<float> GLightVolume, RWTexture3D<float> BLightVolume, RWTexture3D<float> ALightVolume)
{
    return float4(RLightVolume[pos], GLightVolume[pos], BLightVolume[pos], ALightVolume[pos]);
}

int3 GetPos(uint2 threadId, uint3 VolumeSize, uint Loop, uint Axis)
{
    switch (Axis)
    {
        case 0:
            return int3(VolumeSize.x - 1 - Loop, threadId.x, threadId.y);
        case 1:
            return int3(Loop, VolumeSize.y - 1 - threadId.x, threadId.y);
        case 2:
            return int3(VolumeSize.x - 1 - threadId.x, VolumeSize.y - 1 - Loop, threadId.y);
        case 3:
            return int3(threadId.x, Loop, threadId.y);
        case 4:
            return int3(threadId.x, threadId.y, VolumeSize.z - 1 - Loop);
        case 5:
            return int3(threadId.x, VolumeSize.y - 1 - threadId.y, Loop);
        default:
            return int3(0, 0, 0);
    }
}

float2 GetPixOffset(float3 LightPosition, uint Axis)
{
    float3 normLightPosition = LightPosition;
	// Normalize the light position to get the major axis to be one. The other 2 components are then an offset to apply to current pos
	// to read from our read buffer texture.
    switch (Axis)
    {
        case 0:
            normLightPosition /= normLightPosition.x;
            return normLightPosition.yz;
        case 1:
            normLightPosition /= -normLightPosition.x;
            return float2(-normLightPosition.y, normLightPosition.z);
        case 2:
            normLightPosition /= normLightPosition.y;
            return float2(-normLightPosition.x, normLightPosition.z);
        case 3:
            normLightPosition /= -normLightPosition.y;
            return normLightPosition.xz;
        case 4:
            normLightPosition /= normLightPosition.z;
            return normLightPosition.xy;
        case 5:
            normLightPosition /= -normLightPosition.z;
            return float2(normLightPosition.x, -normLightPosition.y);
        default:
            return float2(0, 0);
    }
}


float2 GetUV(float2 pos, float2 texSize, float3 LightPosition, uint Axis) {
    float2 offset = GetPixOffset(LightPosition, Axis);
    return (pos + float2(0.5, 0.5) + offset) / texSize;
}


float3 GetUVW(uint3 pos, float3 dimensions)
{
	// Sample centers of data points.
    return (pos + float3(0.5, 0.5, 0.5)) / dimensions;
}
