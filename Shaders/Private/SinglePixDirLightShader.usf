



float transmittance = 1;

float3 localcamvec = normalize(mul(Parameters.CameraVector, Primitive.WorldToLocal)) * StepSize;

float3 lightenergy = 0;

int3 randpos = int3(Parameters.SvPosition.xy, View.StateFrameIndexMod8);
float rand = float(Rand3DPCG16(randpos).x) / 0xffff;
CurPos += localcamvec * rand.x * Jitter;

//float3 LightVectorWS = normalize(mul(LightVector, Primitive.LocalToWorld));
float3 LightVectorWS = float3(0, 0, 1);

float cursample = 0;

float4 colorsample = 0;
float4 lightsample = 0;

float3 lightedColor = 0;

[loop] for (int i = 0;i < MaxSteps; i++)
{
	// Sample intensity from the volume and get corresponding color-opacity from transfer function.
	cursample = Tex.SampleLevel(TexSampler, saturate(CurPos), 0).r;
	colorsample = TF.SampleLevel(TFSampler, float2(cursample, 0.5), 0);

	colorsample.a *= (256/ MaxSteps);

	// Only care if the sample has at least some alpha.
	if (colorsample.a > 0.01)
	{
		// Get lighting information from illumination volume for current position.
		lightsample.r = RLightVolume.SampleLevel(RLightVolumeSampler, saturate(CurPos), 0);
		lightsample.g = GLightVolume.SampleLevel(GLightVolumeSampler, saturate(CurPos), 0);
		lightsample.b = BLightVolume.SampleLevel(BLightVolumeSampler, saturate(CurPos), 0);
		lightsample.a = ALightVolume.SampleLevel(ALightVolumeSampler, saturate(CurPos), 0);

		float3 dfpos = 2 * (CurPos - 0.5) * Primitive.LocalObjectBoundsMax.x;
		dfpos = TransformLocalPositionToWorld(Parameters, dfpos).xyz;
		float dftracedist = 1;
		float dfshadow = 1;
		float curdist = 0;
		float DistanceAlongCone = 0;
		for (int d = 0;d < DFSteps; d++)
		{
			DistanceAlongCone += curdist;
			curdist = GetDistanceToNearestSurfaceGlobal(dfpos.xyz);

			float SphereSize = DistanceAlongCone * LightTangent;
			dfshadow = min( saturate(curdist / SphereSize) , dfshadow);

			dfpos.xyz += LightVectorWS * dftracedist * curdist;
			dftracedist*= 1.0001;
		}

		// Multiply sampled color with ligth color and adjust intensity according to light strength.
		lightedColor = colorsample.rgb * lightsample.rgb * max(lightsample.a, 0.02) ;//* (dfshadow);

		// Alpha blend back front.
		lightenergy += (colorsample.a * lightedColor) * (transmittance);
		transmittance -= (colorsample.a) * (transmittance);
	}


	CurPos -=
localcamvec;
	if (transmittance <= 0.01) {break;};
}

return float4(lightenergy, transmittance);



////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float numFrames = XYFrames * XYFrames;
float accumdist = 0;
float curdensity = 0;
float transmittance = 1;
float3 localcamvec = normalize(mul(Parameters.CameraVector, Primitive.WorldToLocal)) * StepSize;

float3 invlightdir = 1 / LightVector;

float shadowstepsize = 1 / ShadowSteps;
LightVector *= shadowstepsize*0.5;
ShadowDensity *= shadowstepsize;

float3 LightVectorWS = normalize(mul(LightVector, Primitive.LocalToWorld));

Density *= StepSize;
float3 lightenergy = 0;
float shadowthresh = -log(ShadowThreshold) / ShadowDensity;

int3 randpos = int3(Parameters.SvPosition.xy, View.StateFrameIndexMod8);
float rand = float(Rand3DPCG16(randpos).x) / 0xffff;
CurPos +=  localcamvec * rand.x * Jitter;


for (int i = 0;i <MaxSteps; i++)
{

float cursample = PseudoVolumeTexture(Tex, TexSampler, saturate(CurPos), XYFrames, numFrames).r;

	//Sample Light Absorption and Scattering
	if( cursample > 0.001)
	{
		float3 lpos = CurPos;
		float shadowdist = 0;
		for (int s = 0;s <ShadowSteps; s++)
		{
			lpos +=LightVector;
			float lsample = PseudoVolumeTexture(Tex, TexSampler, saturate(lpos), XYFrames, numFrames).r;

			float3 shadowboxtest = floor(0.5 + (abs(0.5 - lpos)));
			float exitshadowbox = shadowboxtest.x + shadowboxtest.y + shadowboxtest.z;

			if(shadowdist > shadowthresh || exitshadowbox >= 1) break;

			shadowdist += lsample;
		}

		float3 dfpos = 2 * (CurPos - 0.5) * Primitive.LocalObjectBoundsMax.x;
		dfpos = TransformLocalPositionToWorld(Parameters, dfpos).xyz;
		float dftracedist = 1;
		float dfshadow = 1;
		float curdist = 0;
		float DistanceAlongCone = 0;
		for (int d = 0;d < DFSteps; d++)
		{
			DistanceAlongCone += curdist;
			curdist = GetDistanceToNearestSurfaceGlobal(dfpos.xyz);

			float SphereSize = DistanceAlongCone * LightTangent;
			dfshadow = min( saturate(curdist / SphereSize) , dfshadow);

			dfpos.xyz += LightVectorWS * dftracedist * curdist;
			dftracedist*= 1.0001;

		}

		curdensity = 1 - exp(-cursample * Density);
		//curdensity = saturate(cursample * Density);
		//float     shadowterm = exp(-shadowdist * ShadowDensity);
		//float3 absorbedlight = exp(-shadowdist * ShadowDensity) * curdensity;
		lightenergy += exp(-shadowdist * ShadowDensity) * curdensity * dfshadow * transmittance * LightColor;

		transmittance*= 1 - curdensity;

		#if 1

		//Sky Lighting
		shadowdist = 0;

		lpos = CurPos + float3(0,0,0.05);
		float lsample = PseudoVolumeTexture(Tex, TexSampler, saturate(lpos), XYFrames, numFrames).r;
		shadowdist += lsample;
		lpos = CurPos + float3(0, 0, 0.1);
		lsample = PseudoVolumeTexture(Tex, TexSampler, saturate(lpos), XYFrames, numFrames).r;
		shadowdist += lsample;
		lpos = CurPos + float3(0, 0, 0.2);
		lsample = PseudoVolumeTexture(Tex, TexSampler, saturate(lpos), XYFrames, numFrames).r;
		shadowdist += lsample;

		lightenergy+= exp(-shadowdist  * AmbientDensity) * curdensity * SkyColor * transmittance;
		#endif
	}

	CurPos -= localcamvec;
}

#if 1
CurPos += localcamvec  * (1- FinalStep);
float cursample = PseudoVolumeTexture(Tex, TexSampler, saturate(CurPos), XYFrames, numFrames).r;

//Sample Light Absorption and Scattering
if( cursample > 0.001)
{
	float3 lpos = CurPos;
	float shadowdist = 0;

	for (int s = 0; s < ShadowSteps; s++)
	{
		lpos += LightVector;
		float lsample = PseudoVolumeTexture(Tex, TexSampler, saturate(lpos), XYFrames, numFrames).r;

		float3 shadowboxtest = floor(0.5 + (abs(0.5 - lpos)));
		float exitshadowbox = shadowboxtest.x + shadowboxtest.y + shadowboxtest.z;

		if(shadowdist > shadowthresh || exitshadowbox >= 1) break;
		shadowdist += lsample;
	}

float3 dfpos = 2 * (CurPos - 0.5) * Primitive.LocalObjectBoundsMax.x;
dfpos = TransformLocalPositionToWorld(Parameters, dfpos).xyz;
float dftracedist = 1;
float dfshadow = 1;
float curdist = 0;
float DistanceAlongCone = 0;
		for (int df = 0;df < DFSteps; df++)
		{
			DistanceAlongCone += curdist;
			curdist = GetDistanceToNearestSurfaceGlobal(dfpos.xyz);
			float SphereSize = DistanceAlongCone * LightTangent;
			dfshadow = min( saturate(curdist / SphereSize) , dfshadow);
			dfpos.xyz += LightVectorWS  * dftracedist * curdist;
			dftracedist*= 1.0001;
		}

	curdensity = 1 - exp(-cursample * Density * FinalStep);
	//float     shadowterm = exp(-shadowdist * ShadowDensity);
	//float3 absorbedlight = exp(-shadowdist * ShadowDensity) * curdensity;
	lightenergy += exp(-shadowdist * ShadowDensity) * curdensity * dfshadow * transmittance * LightColor;

	transmittance*= 1- curdensity;

	//Sky Lighting
	shadowdist = 0;

	lpos = CurPos + float3(0,0,0.05);
	float lsample = PseudoVolumeTexture(Tex, TexSampler, saturate(lpos), XYFrames, numFrames).r;
	shadowdist += lsample;
	lpos = CurPos + float3(0, 0, 0.1);
	lsample = PseudoVolumeTexture(Tex, TexSampler, saturate(lpos), XYFrames, numFrames).r;
	shadowdist += lsample;
	lpos = CurPos + float3(0, 0, 0.2);
	lsample = PseudoVolumeTexture(Tex, TexSampler, saturate(lpos), XYFrames, numFrames).r;
	shadowdist += lsample;

	//shadowterm    = exp(-shadowdist  * AmbientDensity);
	//absorbedlight = exp(-shadowdist  * AmbientDensity) * curdensity;
	lightenergy += exp(-shadowdist  * AmbientDensity) * curdensity * SkyColor *
transmittance;
}
#endif

return float4( lightenergy, transmittance);


/////////////////////////////////////////////////////////////////////////////
// RB
/////////////////////////////////////////////////////////////////////////////

float scale = length(TransformLocalVectorToWorld(Parameters, float3(1.00000000, 0.00000000, 0.00000000)).xyz);
float localscenedepth = CalcSceneDepth(ScreenAlignedPosition(GetScreenPosition(Parameters)));

float3 camerafwd = mul(float3(0.00000000, 0.00000000, 1.00000000), ResolvedView.ViewToTranslatedWorld);
localscenedepth /= (Primitive.LocalObjectBoundsMax.x * 2 * scale);
localscenedepth /= abs( dot( camerafwd, Parameters.CameraVector ) );

//bring vectors into local space to support object transforms
float3 localcampos = mul(float4(ResolvedView.WorldCameraOrigin, 1.00000000), (Primitive.WorldToLocal)).xyz;
float3 localcamvec = -normalize(mul(Parameters.CameraVector, Primitive.WorldToLocal));

//make camera position 0-1
localcampos = (localcampos / (Primitive.LocalObjectBoundsMax.x * 2)) + 0.5;

float3 invraydir = 1 / localcamvec;

float3 firstintersections = (0 - localcampos) * invraydir;
float3 secondintersections = (1 - localcampos) * invraydir;
float3 closest = min(firstintersections, secondintersections);
float3 furthest = max(firstintersections, secondintersections);

float t0 = max(closest.x, max(closest.y, closest.z));
float t1 = min(furthest.x, min(furthest.y, furthest.z));

float planeoffset = 1 - frac((t0 - length(localcampos - 0.5)) * MaxSteps);

t0 += (planeoffset / MaxSteps) * PlaneAlignment;
t1 = min(t1, localscenedepth);
t0 = max(0, t0);

float boxthickness = max(0, t1 - t0);

float3 entrypos = localcampos + (max(0, t0) * localcamvec);


return float4( entrypos, boxthickness );

///////
// Mine
///////


float scale = length(TransformLocalVectorToWorld(Parameters, float3(1.00000000, 0.00000000, 0.00000000)).xyz);
float localscenedepth = CalcSceneDepth(ScreenAlignedPosition(GetScreenPosition(Parameters)));

float3 camerafwd = mul(float3(0.00000000, 0.00000000, 1.00000000), ResolvedView.ViewToTranslatedWorld);

float maxBound = max(max(Primitive.LocalObjectBoundsMax.x, Primitive.LocalObjectBoundsMax.y), Primitive.LocalObjectBoundsMax.z);

localscenedepth /= (Primitive.LocalObjectBoundsMax.x * 2 * scale);
localscenedepth /= abs( dot( camerafwd, Parameters.CameraVector ) );

//bring vectors into local space to support object transforms
float3 localcampos = mul(float4(ResolvedView.WorldCameraOrigin, 1.00000000), (Primitive.WorldToLocal)).xyz;
float3 localcamvec = -normalize(mul(Parameters.CameraVector, Primitive.WorldToLocal));

//make camera position 0-1
localcampos = (localcampos / (Primitive.LocalObjectBoundsMax.x * 2)) + 0.5;

float3 invraydir = 1 / localcamvec;

float3 firstintersections = (0 - localcampos) * invraydir;
float3 secondintersections = (1 - localcampos) * invraydir;
float3 closest = min(firstintersections, secondintersections);
float3 furthest = max(firstintersections, secondintersections);

float t0 = max(closest.x, max(closest.y, closest.z));
float t1 = min(furthest.x, min(furthest.y, furthest.z));

float planeoffset = 1 - frac((t0 - length(localcampos - 0.5)) * MaxSteps);

t0 += (planeoffset / MaxSteps) * PlaneAlignment;
t1 = min(t1, localscenedepth);
t0 = max(0, t0);

float boxthickness = max(0, t1 - t0);

float3 entrypos = localcampos + (max(0, t0) * localcamvec);
float3 exitpos = localcampos + (max(0, t1) * localcamvec);

return float4( entrypos, boxthickness );




