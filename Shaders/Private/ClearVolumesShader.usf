#include "/Engine/Private/Common.ush"

// Thx Temaran for original HLSL & usage example

/**
	Uniform Buffers have been replaced by regular shader parameters, as most are subject to change between calls.
*/

RWTexture3D<float> RLightVolume;
RWTexture3D<float> GLightVolume;
RWTexture3D<float> BLightVolume;
RWTexture3D<float> ALightVolume;

int ZSize;

float RClearValue;
float GClearValue;
float BClearValue;
float AClearValue;

[numthreads(32, 32, 1)]
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{
    for (int i = 0; i <= ZSize; i++)
    {
        RLightVolume[int3(ThreadId.x, ThreadId.y, i)] = RClearValue;
        GLightVolume[int3(ThreadId.x, ThreadId.y, i)] = GClearValue;
        BLightVolume[int3(ThreadId.x, ThreadId.y, i)] = BClearValue;
        ALightVolume[int3(ThreadId.x, ThreadId.y, i)] = AClearValue;

    }
}



// Deprecated
//int3 GetPosIncrementVector()
//{
//    switch (Axis)
//    {
//        case 0:
//            return int3(-1,  0,  0);
//        case 1:
//            return int3( 1,  0,  0);
//        case 2:
//            return int3( 0, -1,  0);
//        case 3:
//            return int3( 0,  1,  0);
//        case 4:
//            return int3( 0,  0, -1);
//        case 5:
//            return int3( 0,  0,  1);
//		default:
//            return int3(0, 0, 0);
//    }
//}

//int3 GetFirstPos(uint3 threadId, uint3 VolumeSize)
//{
//    switch (Axis)
//    {
//        case 0:
//            return int3(VolumeSize.x - 1, threadId.x, threadId.y);
//        case 1:
//            return int3(0, threadId.x, threadId.y);
//        case 2:
//            return int3(threadId.x, VolumeSize.y - 1, threadId.y);
//        case 3:
//            return int3(threadId.x, 0, threadId.y);
//        case 4:
//            return int3(threadId.x, threadId.y, VolumeSize.z - 1);
//        case 5:
//            return int3(threadId.x, threadId.y, 0);
//        default:
//            return int3(0, 0, 0);
//    }
//}

//int3 GetLastPos(uint3 threadId, uint3 VolumeSize)
//{
//    switch (Axis)
//    {
//        case 0:
//            return int3(0, threadId.x, threadId.y);
//        case 1:
//            return int3(VolumeSize.x - 1, threadId.x, threadId.y);
//        case 2:
//            return int3(threadId.x, 0, threadId.y);
//        case 3:
//            return int3(threadId.x, VolumeSize.y - 1, threadId.y);
//        case 4:
//            return int3(threadId.x, threadId.y, 0);
//        case 5:
//            return int3(threadId.x, threadId.y, VolumeSize.z - 1);
//        default:
//            return int3(0, 0, 0);
//    }
//}

//int GetLoopCount(uint3 VolumeSize)
//{
//    switch (Axis)
//    {
//        case 0:
//        case 1:
//            return VolumeSize.x;
//        case 2:
//        case 3:
//            return VolumeSize.y;
//        case 4:
//        case 5:
//            return VolumeSize.z;
//        default:
//            return 1;
//    }
//}


// Get location of the pixel in the read/write buffer for current position.
//uint2 GetPixLocation(uint3 pos, uint3 dimensions)
//{
//    switch (Axis)
//    {
//        case 0:
//            return pos.yz;
//        case 1:
//            return uint2(dimensions.y - pos.y - 1, pos.z);
//        case 2:
//            return uint2(dimensions.x - pos.x - 1, pos.z);
//        case 3:
//            return pos.xz;
//        case 4:
//            return pos.xy;
//        case 5:
//            return uint2(pos.x, dimensions.y - pos.y - 1);
//        default:
//            return uint2(0, 0);
//    }
//}