#include "/Engine/Private/Common.ush"
#include "DirLightCommon.usf"

// Thx Temaran for original HLSL & usage example

/**
	Uniform Buffers have been replaced by regular shader parameters, as most are subject to change between calls.
*/

RWTexture3D<float> ALightVolume;

RWTexture2D<float> WriteBuffer;
Texture2D ReadBuffer;

int Loop;

Texture3D Volume;

Texture2D TransferFunc;

int bAdded;

float3 LocalClippingCenter;
float3 LocalClippingDirection;

float2 TFIntensityDomain;

float2 PrevPixelOffset;

float3x3 PermutationMatrix;

// The shader code is common for all axes and always 2D in X and Y space
// If going along X - threadgroup X = Volume Y dimension, threadgroup Y = Volume Z dimension
// If going along Y - threadgroup X = Volume X dimension, threadgroup Y = Volume Z dimension
// If going along Z - threadgroup X = Volume X dimension, threadgroup Y = Volume Y dimension (the simple case)

SamplerState TransferFuncSampler;

SamplerState VolumeSampler;

// The buffer shall use a hard-set border color (the light outside the volume is not occluded by anything ->
// sampling outside means full original light.
SamplerState ReadBufferSampler;

[numthreads(32, 32, 1)]
void MainComputeShader(uint2 PixelLoc : SV_DispatchThreadID)
{
    //int3 pos = GetPosNew(pixelLoc, VolumeSize, Loop, Axis);
    
    int3 pos = mul(int3(PixelLoc.x, PixelLoc.y, Loop), PermutationMatrix);

    float texSizeX, texSizeY;
    WriteBuffer.GetDimensions(texSizeX, texSizeY);

    uint sizeX, sizeY, sizeZ;
    ALightVolume.GetDimensions(sizeX, sizeY, sizeZ);
    uint3 uResolution = uint3(sizeX, sizeY, sizeZ);

    float3 CurrentUVW = GetUVW(pos, uResolution);

    float2 PreviousUV = (PixelLoc + PrevPixelOffset) / float2(texSizeX, texSizeY);
    float PreviousLightAlpha = ReadBuffer.SampleLevel(ReadBufferSampler, PreviousUV, 0);
    float CurrentLightAlpha;

    float DistanceToCuttingPlane = dot(CurrentUVW - LocalClippingCenter, LocalClippingDirection);
    // Ignore clipped regions.
    if (DistanceToCuttingPlane < 0)
    {
        // Avoid calculations that would be unnecessary. Just propagate previous light unchanged and add it to volume.
        CurrentLightAlpha = PreviousLightAlpha;
    }
    else
    {
        float cursample = Volume.SampleLevel(VolumeSampler, CurrentUVW, 0);
        cursample = RemapIntensity(cursample, TFIntensityDomain);
        // Get Color&alpha from intensity
        cursample = TransferFunc.SampleLevel(TransferFuncSampler, float2(cursample, 0.5f), 0).a;
        CurrentLightAlpha = PreviousLightAlpha * (1 - (cursample));
    }

	// The read/write buffers have always positive values (the alpha of current light being propagated)
    WriteBuffer[PixelLoc] = CurrentLightAlpha; 
    // Adding Color to the volume depends on if we're adding or removing.
    // if we're removing a light, multiply alpha by -1.
    ALightVolume[pos] = ALightVolume[pos] + (CurrentLightAlpha * bAdded);
}




//#include "/Engine/Private/Common.ush"
//#include "DirLightCommon.usf"

//// The shader code is common for all axes and always 2D in X and Y space
//// If going along X - threadgroup X = Volume Y dimension, threadgroup Y = Volume Z dimension, Loop in X
//// If going along Y - threadgroup X = Volume X dimension, threadgroup Y = Volume Z dimension, Loop in Y
//// If going along Z - threadgroup X = Volume X dimension, threadgroup Y = Volume Y dimension, Loop in Z (the simple case)

//RWTexture3D<float> ALightVolume;

//Texture3D Volume;
//SamplerState VolumeSampler;

//Texture2D TransferFunc;
//SamplerState TransferFuncSampler;

//float2 TFIntensityDomain;

//Texture2D ReadBuffer;
//SamplerState ReadBufferSampler;

//RWTexture2D<float> WriteBuffer;

//int Loop;
//float3x3 PermutationMatrix;

//// Todo make a 4vec out of this
//float3 LocalClippingCenter;
//float3 LocalClippingDirection;

//float2 PrevPixelOffset;

//int bAdded;


//}