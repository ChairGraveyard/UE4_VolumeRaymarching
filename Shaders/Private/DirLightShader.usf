#include "/Engine/Private/Common.ush"
#include "DirLightCommon.usf"
// Thx Temaran for original HLSL & usage example

RWTexture3D<float> RLightVolume;
RWTexture3D<float> GLightVolume;
RWTexture3D<float> BLightVolume;
RWTexture3D<float> ALightVolume;

RWTexture2D<float4> WriteBuffer;
Texture2D ReadBuffer;

// Going from
// 0 = +X, 1 = -X, 2 = Y, 3 = -Y, 4 = Z, 5 = -Z
uint Axis;
uint Loop;

Texture3D Volume;

Texture2D TransferFunc;

float3 LightPosition;

float3 LightColor;

float LightIntensity;

int bAdded;

float3 LocalClippingCenter;

float3 LocalClippingDirection;

float Weight;

float2 TFIntensityDomain;

// The shader code is common for all axes and always 2D in X and Y space
// If going along X - threadgroup X = Volume Y dimension, threadgroup Y = Volume Z dimension
// If going along Y - threadgroup X = Volume X dimension, threadgroup Y = Volume Z dimension
// If going along Z - threadgroup X = Volume X dimension, threadgroup Y = Volume Y dimension (the simple case)

SamplerState TransferFuncSampler;
SamplerState VolumeSampler;

// The buffer shall use a hard-set border color (the light outside the volume is not occluded by anything ->
// sampling outside means full original light.
SamplerState ReadBufferSampler;

[numthreads(32, 32, 1)]
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{
	//Set up some variables we are going to need
    float sizeX, sizeY, sizeZ;
    ALightVolume.GetDimensions(sizeX, sizeY, sizeZ);
    uint3 uResolution = uint3(sizeX, sizeY, sizeZ);

	// Todo keep whole float4, not just alpha
    uint2 pixelLoc = ThreadId.xy;
    int3 pos = GetPos(pixelLoc, uResolution, Loop, Axis);
    float4 oldColor = GetColor(pos, RLightVolume, GLightVolume, BLightVolume, ALightVolume);

    if (Loop == 0)
    {
        // float4 color = float4(LightColor, Weight * LightIntensity);
        // The (-1,-1) sample is here just to make sure that the border color is set properly.
        // If the border color wasn't good, this would fuck up.
        float4 color = ReadBuffer.SampleLevel(ReadBufferSampler, float2(-1, -1), 0);
        WriteBuffer[pixelLoc] = color;
        color.a *= bAdded;
        AddColor(pos, color, oldColor, RLightVolume, GLightVolume, BLightVolume, ALightVolume);
    }
    else
    {

        float texSizeX, texSizeY;
        WriteBuffer.GetDimensions(texSizeX, texSizeY);
        
        float cursample = 0;
        float4 colorsample = 0;

		// TODO! Set pix offset as a uniform. EVEN better : Save it in UV offset!
		// + (0.5, 0.5) to sample the centers of pixels!
        float2 prevXY = pixelLoc + float2(0.5, 0.5) + GetPixOffset(LightPosition, Axis);
        float2 prevUV = (prevXY) / float2(texSizeX, texSizeY);
        float4 previousLightColor = ReadBuffer.SampleLevel(ReadBufferSampler, prevUV, 0);
	
    float3 iResolution = float3(sizeX, sizeY, sizeZ);
        float3 uvw = GetUVW(pos, iResolution);

        // Ignore clipped.
        if (dot(uvw - LocalClippingCenter, LocalClippingDirection) < 0)
        {
            colorsample = float4(0, 0, 0, 0);
        }
        else
        {
            cursample = Volume.SampleLevel(VolumeSampler, uvw, 0);
            cursample = RemapIntensity(cursample, TFIntensityDomain);
 // Get Color&alpha from intensity
            colorsample = TransferFunc.SampleLevel(TransferFuncSampler, float2(cursample, 0.5f), 0);
        }

        float alpha = 0;
        alpha = previousLightColor.a * (1 - (colorsample.a));

		// The read/write buffers have always positive alpha
        WriteBuffer[pixelLoc] = float4(1.0, 1.0, 1.0, alpha);
		// Adding Color to the volume depends on if we're adding or removing.
        // if we're removing a light, multiply initial alpha by -1.
        alpha *= bAdded;
        AddColor(pos, float4(1.0, 1.0, 1.0, alpha), oldColor, RLightVolume, GLightVolume, BLightVolume, ALightVolume);
		// TODO handle colors properly!

	// Sample readBuffer at [pos - lightVec]
    }
    
}



// Deprecated
//int3 GetPosIncrementVector()
//{
//    switch (Axis)
//    {
//        case 0:
//            return int3(-1,  0,  0);
//        case 1:
//            return int3( 1,  0,  0);
//        case 2:
//            return int3( 0, -1,  0);
//        case 3:
//            return int3( 0,  1,  0);
//        case 4:
//            return int3( 0,  0, -1);
//        case 5:
//            return int3( 0,  0,  1);
//		default:
//            return int3(0, 0, 0);
//    }
//}

//int3 GetFirstPos(uint3 threadId, uint3 VolumeSize)
//{
//    switch (Axis)
//    {
//        case 0:
//            return int3(VolumeSize.x - 1, threadId.x, threadId.y);
//        case 1:
//            return int3(0, threadId.x, threadId.y);
//        case 2:
//            return int3(threadId.x, VolumeSize.y - 1, threadId.y);
//        case 3:
//            return int3(threadId.x, 0, threadId.y);
//        case 4:
//            return int3(threadId.x, threadId.y, VolumeSize.z - 1);
//        case 5:
//            return int3(threadId.x, threadId.y, 0);
//        default:
//            return int3(0, 0, 0);
//    }
//}

//int3 GetLastPos(uint3 threadId, uint3 VolumeSize)
//{
//    switch (Axis)
//    {
//        case 0:
//            return int3(0, threadId.x, threadId.y);
//        case 1:
//            return int3(VolumeSize.x - 1, threadId.x, threadId.y);
//        case 2:
//            return int3(threadId.x, 0, threadId.y);
//        case 3:
//            return int3(threadId.x, VolumeSize.y - 1, threadId.y);
//        case 4:
//            return int3(threadId.x, threadId.y, 0);
//        case 5:
//            return int3(threadId.x, threadId.y, VolumeSize.z - 1);
//        default:
//            return int3(0, 0, 0);
//    }
//}

//int GetLoopCount(uint3 VolumeSize)
//{
//    switch (Axis)
//    {
//        case 0:
//        case 1:
//            return VolumeSize.x;
//        case 2:
//        case 3:
//            return VolumeSize.y;
//        case 4:
//        case 5:
//            return VolumeSize.z;
//        default:
//            return 1;
//    }
//}


// Get location of the pixel in the read/write buffer for current position.
//uint2 GetPixLocation(uint3 pos, uint3 dimensions)
//{
//    switch (Axis)
//    {
//        case 0:
//            return pos.yz;
//        case 1:
//            return uint2(dimensions.y - pos.y - 1, pos.z);
//        case 2:
//            return uint2(dimensions.x - pos.x - 1, pos.z);
//        case 3:
//            return pos.xz;
//        case 4:
//            return pos.xy;
//        case 5:
//            return uint2(pos.x, dimensions.y - pos.y - 1);
//        default:
//            return uint2(0, 0);
//    }
//}