# pragma once

#include "DirLightCommon.usf"

// Returns true if CurPos is clipped by the clipping plane defined by the center and direction.
bool IsCurPosClipped(float3 CurPos, float3 ClippingCenter, float3 ClippingDirection) {
    return (dot(CurPos - ClippingCenter, ClippingDirection) < 0);
}

// Samples a Label volume and corrects the opacity to account for StepSize and volume size.
float4 SampleLabelVolume(float3 CurPos, float StepSize, Texture3D Volume, SamplerState VolumeSampler) {
    float4 RetVal = Volume.SampleLevel(VolumeSampler, saturate(CurPos), 0);
    RetVal.a = 1.0 - pow(1.0 - RetVal.a, (StepSize) * RAYMARCH_MAGIC_NUMBER);
    return RetVal;
}

// Adds current sampled light to the LightEnergy and Opacity
void AddLightAndOpacity(inout float3 LightEnergy, inout float Opacity, in float4 CurrentSample) {
    LightEnergy = LightEnergy + (CurrentSample.rgb * CurrentSample.a * (1.0 - Opacity));
    Opacity = Opacity + (CurrentSample.a * (1.0 - Opacity));
}

// Gets the Distance Field light multiplier (even though it's named GetDFShadow, the return value is actualy the opposite - the amount of light preserved)
float GetDFShadow(float3 CurPos, int DFSteps, float LightTangent, float3 LightVectorWS, FMaterialPixelParameters MaterialParameters) {
    float3 DFPos = 2 * (CurPos - 0.5) * Primitive.LocalObjectBoundsMax.x;
    DFPos = TransformLocalPositionToWorld(MaterialParameters, DFPos).xyz;

    float dftracedist = 1;

    float dfshadow = 1;
    float curdist = 0;
    float DistanceAlongCone = 0;

		for (int d = 0;d < DFSteps; d++)
		{
			DistanceAlongCone += curdist;
			curdist = GetDistanceToNearestSurfaceGlobal(DFPos.xyz);

            float SphereSize = DistanceAlongCone * LightTangent;
			dfshadow = min( saturate(curdist / SphereSize) , dfshadow);

			DFPos.xyz += LightVectorWS * dftracedist * curdist;
			dftracedist*= 1.0001;
		}
    return dfshadow;
}