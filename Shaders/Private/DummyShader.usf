

float3 localcamvec = normalize(mul(Parameters.CameraVector, Primitive.WorldToLocal)) * StepSize;

float3 lightenergy = 0;
float opacity = 0;

int3 randpos = int3(Parameters.SvPosition.xy, View.StateFrameIndexMod8);
float rand = float(Rand3DPCG16(randpos).x) / 0xffff;
CurPos += localcamvec * rand.x * Jitter;

//float3 LightVectorWS = normalize(mul(LightVector, Primitive.LocalToWorld));
float3 LightVectorWS = float3(1, 1, 1);

float4 colorsample = 0;
float lightAlpha = 0;

// Increase by localcamvec at the beginning, so that the cycle always ends at the right CurPos
CurPos += localcamvec;
int i = 0;
for (i = 0;i < MaxSteps; i++)
{
	CurPos -= localcamvec;
    // float current = DistanceField.SampleLevel(DistanceFieldSampler, saturate(CurPos), 0).r;
    //if (current > StepSize) {
    //    int steps = floor(current / StepSize);
    //    i += steps - 1;
    //    CurPos -= steps * localcamvec;
    //    continue;
    //}

    // Labels not affected by clipping!
    colorsample = SampleLabelVolume(CurPos, StepSize, LabelVolume, LabelVolumeSampler);
    AddLightAndOpacity(lightenergy, opacity, colorsample);

	// Anything that is clipped by the clipping plane shall be ignored.
	if (IsCurPosClipped(CurPos, ClippingCenter, ClippingDirection)) {
		continue;
	}

	// Sample intensity from the volume and get corresponding color-opacity from transfer function.
    colorsample = SampleDataVolume(CurPos, StepSize, Tex, TexSampler, TF, TFSampler, TFIntensityDomain, 0);

	// Get lighting information from illumination volume for current position.
	// Take the lighting information a little bit closer to the viewer, so that illuminated surfaces don't self-shadow themselves
	lightAlpha = ALightVolume.SampleLevel(ALightVolumeSampler, saturate(CurPos), 0);
    // float dfShadow = GetDFShadow(CurPos, DFSteps, LightTangent, LightVectorWS, Parameters);
	// Multiply sampled color with ligth color and adjust intensity according to light strength.
	colorsample.rgb = colorsample.rgb * lightAlpha;// * (dfShadow);
    AddLightAndOpacity(lightenergy, opacity, colorsample);

	if (opacity > 0.99) {
		opacity = 1;
		break;
	};
}


// Handle FinalStep (only if we went through all the previous steps and there is a final step)
if (i == MaxSteps && FinalStep > 0) {
// Go back to the previous location, so we can perform final step.
    StepSize *= FinalStep;
    CurPos -= localcamvec * (FinalStep);
    // Labels not affected by clipping!
    colorsample = SampleLabelVolume(CurPos, StepSize, LabelVolume, LabelVolumeSampler);
    AddLightAndOpacity(lightenergy, opacity, colorsample);
   
	// If the final step is clipped, just return.
	if (IsCurPosClipped(CurPos, ClippingCenter, ClippingDirection)) {
        return float4(lightenergy, opacity);
	}

	// Sample intensity from the volume and get corresponding color-opacity from transfer function.
    colorsample = SampleDataVolume(CurPos, StepSize, Tex, TexSampler, TF, TFSampler, TFIntensityDomain, 0);

    // Get lighting information from illumination volume for current position.
	// Take the lighting information a little bit closer to the viewer, so that illuminated surfaces don't self-shadow themselves
	lightAlpha = ALightVolume.SampleLevel(ALightVolumeSampler, saturate(CurPos), 0);

	// Multiply sampled color with ligth color and adjust intensity according to light strength.
	colorsample.rgb = colorsample.rgb * lightAlpha;//* (dfshadow);
    AddLightAndOpacity(lightenergy, opacity, colorsample);
}

return float4(lightenergy, opacity);


///
///
/// Pure Intensity follows
///
///

float3 localcamvec = normalize(mul(Parameters.CameraVector, Primitive.WorldToLocal)) * StepSize;

int3 randpos = int3(Parameters.SvPosition.xy, View.StateFrameIndexMod8);
float rand = float(Rand3DPCG16(randpos).x) / 0xffff;
CurPos += localcamvec * rand.x * Jitter;

float cursample = 0;
float4 colorsample = float4(0, 0, 0, 0);

float3 lightenergy = 0;
float opacity = 0;

[loop] for (int i = 0;i < MaxSteps; i++)
{
    // Labels not affected by clipping!
    if(LabelVolumeEnabled) {
        float4 labelValue = SampleLabelVolume(CurPos, StepSize, LabelVolume, LabelVolumeSampler);
        AddLightAndOpacity(lightenergy, opacity, labelValue);
    }

	// Anything that is clipped by the clipping plane shall be ignored.
	if (IsCurPosClipped(CurPos, ClippingCenter, ClippingDirection)) {
		CurPos -= localcamvec;
		continue;
	}

	// Sample first non-clipped intensity
	cursample = Tex.SampleLevel(TexSampler, saturate(CurPos), 0).r;
	colorsample = float4(cursample, cursample, cursample, 1);
    AddLightAndOpacity(lightenergy, opacity, colorsample);
    break;
}

// Handle FinalStep
		CurPos -= localcamvec * (FinalStep);

if (i == MaxSteps && FinalStep > 0 && dot(CurPos - ClippingCenter, ClippingDirection) >= 0) {

    cursample = Tex.SampleLevel(TexSampler, saturate(CurPos), 0).r;
	colorsample = float4(cursample, cursample, cursample, 1);
    AddLightAndOpacity(lightenergy, opacity, colorsample);
}

return float4(lightenergy, opacity);




///
///
/// Shadow visualization follows
///
///




float3 localcamvec = normalize(mul(Parameters.CameraVector, Primitive.WorldToLocal)) * StepSize;

float3 lightenergy = 0;
float opacity = 0;

int3 randpos = int3(Parameters.SvPosition.xy, View.StateFrameIndexMod8);
float rand = float(Rand3DPCG16(randpos).x) / 0xffff;
CurPos += localcamvec * rand.x * Jitter;

float lightAlpha = 0;

float Intensity = CorrectForStepSize(0.005, StepSize);

int i = 0;
for (i = 0;i < MaxSteps; i++)
{

	// Anything that is clipped by the clipping plane shall be ignored.
	if (IsCurPosClipped(CurPos, ClippingCenter, ClippingDirection)) {
		CurPos -= localcamvec;
		continue;
	}

    // Uniform density - like very thin fog
    float CurSample = LightVolume.SampleLevel(LightVolumeSampler, saturate(CurPos), 0).r;

float4 ColorSample = float4(CurSample, CurSample, CurSample, Intensity);
	// Sample intensity from the volume and get corresponding color-opacity from transfer function.
    AddLightAndOpacity(lightenergy, opacity, ColorSample);

	if (opacity > 0.99) {
		opacity = 1;
		break;
	};
	CurPos -= localcamvec;
}


// Handle FinalStep (only if we went through all the previous steps and there is a final step)
if (i == MaxSteps && FinalStep > 0) {
    // Go back to the previous location, so we can perform final step.
    CurPos += (1 - FinalStep) * localcamvec;
    StepSize *= FinalStep;
  
  // If the final step is clipped, just return.
	if (IsCurPosClipped(CurPos, ClippingCenter, ClippingDirection)) {
        return float4(lightenergy, opacity);
	}

        // Uniform density - like very thin fog
    float CurSample = LightVolume.SampleLevel(LightVolumeSampler, saturate(CurPos), 0).r;

float4 ColorSample = float4(CurSample, CurSample, CurSample, Intensity);
	// Sample intensity from the volume and get corresponding color-opacity from transfer function.

        AddLightAndOpacity(lightenergy, opacity, ColorSample);
	
}
return float4(lightenergy, opacity);
