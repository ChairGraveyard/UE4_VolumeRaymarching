

float3 localcamvec = normalize(mul(Parameters.CameraVector, Primitive.WorldToLocal)) * StepSize;

float3 lightenergy = 0;
float opacity = 0;

int3 randpos = int3(Parameters.SvPosition.xy, View.StateFrameIndexMod8);
float rand = float(Rand3DPCG16(randpos).x) / 0xffff;
CurPos += localcamvec * rand.x * Jitter;

//float3 LightVectorWS = normalize(mul(LightVector, Primitive.LocalToWorld));
float3 LightVectorWS = float3(1, 1, 1);

float4 colorsample = 0;
float lightAlpha = 0;


int i = 0;
for (i = 0;i < MaxSteps; i++)
{
    // Labels not affected by clipping!
    if(LabelVolumeEnabled) {
        float4 labelValue = SampleLabelVolume(CurPos, StepSize, LabelVolume, LabelVolumeSampler);
        AddLightAndOpacity(lightenergy, opacity, labelValue);
    }

	// Anything that is clipped by the clipping plane shall be ignored.
	if (IsCurPosClipped(CurPos, ClippingCenter, ClippingDirection)) {
		CurPos -= localcamvec;
		continue;
	}
	// Sample intensity from the volume and get corresponding color-opacity from transfer function.
    colorsample = SampleDataVolume(CurPos, StepSize, Tex, TexSampler, TF, TFSampler, TFIntensityDomain);

	// Only care if the sample has at least some alpha.
	if (colorsample.a > 0.01)
	{
		// Get lighting information from illumination volume for current position.
		// Take the lighting information a little bit closer to the viewer, so that illuminated surfaces don't self-shadow themselves
		lightAlpha = ALightVolume.SampleLevel(ALightVolumeSampler, saturate(CurPos), 0);
        float dfShadow = GetDFShadow(CurPos, DFSteps, LightTangent, LightVectorWS, Parameters);
		// Multiply sampled color with ligth color and adjust intensity according to light strength.
		colorsample.rgb = colorsample.rgb * lightAlpha * (dfShadow);
        AddLightAndOpacity(lightenergy, opacity, colorsample);
	}

	if (opacity > 0.99) {
		opacity = 1;
		break;
	};
	CurPos -= localcamvec;
}


// Handle FinalStep (only if we went through all the previous steps and there is a final step)
if (i == MaxSteps && FinalStep > 0) {
// Go back to the previous location, so we can perform final step.
    CurPos += localcamvec;

    StepSize *= FinalStep;
    CurPos -= localcamvec * (FinalStep);
    // Labels not affected by clipping!
   if(LabelVolumeEnabled) {
        float4 labelValue = SampleLabelVolume(CurPos, StepSize, LabelVolume, LabelVolumeSampler);
        AddLightAndOpacity(lightenergy, opacity, labelValue);
   }
	// If the final step is clipped, just return.
	if (IsCurPosClipped(CurPos, ClippingCenter, ClippingDirection)) {
        return float4(lightenergy, opacity);
	}

	// Sample intensity from the volume and get corresponding color-opacity from transfer function.
    colorsample = SampleDataVolume(CurPos, StepSize, Tex, TexSampler, TF, TFSampler, TFIntensityDomain);

	// Only care if the sample has at least some alpha.
	if (colorsample.a > 0.01)
	{
		// Get lighting information from illumination volume for current position.
		// Take the lighting information a little bit closer to the viewer, so that illuminated surfaces don't self-shadow themselves
		lightAlpha = ALightVolume.SampleLevel(ALightVolumeSampler, saturate(CurPos), 0);

		// Multiply sampled color with ligth color and adjust intensity according to light strength.
		colorsample.rgb = colorsample.rgb * lightAlpha;//* (dfshadow);
        AddLightAndOpacity(lightenergy, opacity, colorsample);
	}
}
return float4(lightenergy, opacity);
