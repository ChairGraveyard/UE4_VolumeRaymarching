#include "/Engine/Private/Common.ush"
#include "RaymarcherCommon.usf"

// Thx Temaran for original HLSL & usage example

/**
	Uniform Buffers have been replaced by regular shader parameters, as most are subject to change between calls.
*/

RWTexture3D<float> ALightVolume;

RWTexture2D<float> WriteBuffer;
Texture2D ReadBuffer;

int Loop;

Texture3D Volume;

Texture2D TransferFunc;

int bAdded;

float3 LocalClippingCenter;
float3 LocalClippingDirection;

float2 TFIntensityDomain;

float2 PrevPixelOffset;

float3x3 PermutationMatrix;

// The shader code is common for all axes and always 2D in X and Y space
// If going along X - threadgroup X = Volume Y dimension, threadgroup Y = Volume Z dimension
// If going along Y - threadgroup X = Volume X dimension, threadgroup Y = Volume Z dimension
// If going along Z - threadgroup X = Volume X dimension, threadgroup Y = Volume Y dimension (the simple case)

SamplerState TransferFuncSampler;

SamplerState VolumeSampler;

// The buffer shall use a hard-set border color (the light outside the volume is not occluded by anything ->
// sampling outside means full original light.
SamplerState ReadBufferSampler;

float StepSize;
float3 UVWOffset;

[numthreads(16, 16, 1)]
void MainComputeShader(uint2 PixelLoc : SV_DispatchThreadID)
{
    int3 pos = mul(int3(PixelLoc.x, PixelLoc.y, Loop), PermutationMatrix);

    float texSizeX, texSizeY;
    WriteBuffer.GetDimensions(texSizeX, texSizeY);

    uint sizeX, sizeY, sizeZ;
    ALightVolume.GetDimensions(sizeX, sizeY, sizeZ);
    uint3 uResolution = uint3(sizeX, sizeY, sizeZ);
        
    //// Sample the volume intensity halfway between current voxel and previous voxel.
    float3 SampleUVW = GetUVW(pos, uResolution) + UVWOffset;

    float2 PreviousUV = ((PixelLoc + float2(0.5, 0.5)) / float2(texSizeX, texSizeY)) + PrevPixelOffset;
    float PreviousLightAlpha = ReadBuffer.SampleLevel(ReadBufferSampler, PreviousUV, 0);
    float CurrentLightAlpha;

    float DistanceToCuttingPlane = dot(SampleUVW - LocalClippingCenter, LocalClippingDirection);

    // Calculate the distance of the current voxel from the cutting plane in voxel space 
    float3 CuttingPlaneIntersectPoint = SampleUVW + LocalClippingDirection * DistanceToCuttingPlane;
    float3 CuttingPlaneOffset = SampleUVW - CuttingPlaneIntersectPoint;
    // Offset to cutting plane in voxel space.
    float3 VoxelCuttingPlaneOffset = CuttingPlaneOffset * uResolution;
    // Distance from cutting plane to voxel center in voxel space.
    float VoxelDistance = length(VoxelCuttingPlaneOffset);

    // Case when the voxel is very close to the cutting plane -> weight the alpha in the voxel by an
    // aproximation of the part of the cube that's not cut away - this prevents noticeable clipping plane artifacts
    // (even though it's not even close to being mathematically correct).
    if (VoxelDistance < SQRT_3_HALF)
    {
        // Use signum of the DistanceToCuttingPlane, because the weight of a voxel, that's barely
        // NOT cut away should icnrease with the distance to the cutting plane, but the weight
        // of a pixel cut away will decrease with the distance to the cutting plane.
        // If the distance of the center of the voxel to the cutting plane is  0, then exactly half is cut away.
        float AlphaWeight = clamp(0.5 + (ONE_OVER_SQRT_3 * VoxelDistance * sign(DistanceToCuttingPlane)), 0, 1);
        float CurrentSample = SampleDataVolume(SampleUVW, StepSize, Volume, VolumeSampler, TransferFunc, TransferFuncSampler, TFIntensityDomain).a;
        CurrentSample *= AlphaWeight;
        CurrentLightAlpha = PreviousLightAlpha * (1 - (CurrentSample));
    }
    else if (DistanceToCuttingPlane < 0.0) // Case of being normally cut away.
    {
        // Avoid reads that would be unnecessary. Just propagate previous light unchanged and add it to volume.
        CurrentLightAlpha = PreviousLightAlpha;
    }
    else // Case of being not cut away at all.
    {
        float CurrentSample = SampleDataVolume(SampleUVW, StepSize, Volume, VolumeSampler, TransferFunc, TransferFuncSampler, TFIntensityDomain).a;
        CurrentLightAlpha = PreviousLightAlpha * (1 - (CurrentSample));
    }

	// The read/write buffers have always positive values (the alpha of current light being propagated)
    WriteBuffer[PixelLoc] = CurrentLightAlpha; 
    // Adding Color to the volume depends on if we're adding or removing.
    // if we're removing a light, multiply alpha by -1.
    ALightVolume[pos] = ALightVolume[pos] + (CurrentLightAlpha * bAdded);
}
