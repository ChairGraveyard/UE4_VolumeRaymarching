#include "/Engine/Private/Common.ush"

// Base shader origin:
// https://www.shadertoy.com/view/MdXSzS
// The Big Bang - just a small explosion somewhere in a massive Galaxy of Universes.
// Outside of this there's a massive galaxy of 'Galaxy of Universes'... etc etc. :D
//
// HLSL translation and parameterization by Temaran

RWTexture2D<half4> OutputSurface;

float SimulationSpeed;

float TimeElapsed;

[numthreads(32, 32, 1)]
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{
	//Set up some variables we are going to need
    float sizeX, sizeY;
    OutputSurface.GetDimensions(sizeX, sizeY);

    float2 iResolution = float2(sizeX, sizeY);
    float2 uv = (ThreadId.xy / iResolution.xy) - 0.5;
    float iGlobalTime = SimulationSpeed * TimeElapsed;

	//This shader code is from www.shadertoy.com, converted to HLSL by me. If you have not checked out shadertoy yet, you REALLY should!!
    float t = iGlobalTime * 0.1 + ((0.25 + 0.05 * sin(iGlobalTime * 0.1)) / (length(uv.xy) + 0.07)) * 2.2;
    float si = sin(t);
    float co = cos(t);
    float2x2 ma = { co, si, -si, co };

    float v1, v2, v3;
    v1 = v2 = v3 = 0.0;

    float s = 0.0;
    for (int i = 0; i < 90; i++)
    {
        float3 p = s * float3(uv, 0.0);
        p.xy = mul(p.xy, ma);
        p += float3(0.22, 0.3, s - 1.5 - sin(iGlobalTime * 0.13) * 0.1);

        for (int i = 0; i < 8; i++)
            p = abs(p) / dot(p, p) - 0.659;

        v1 += dot(p, p) * 0.0015 * (1.8 + sin(length(uv.xy * 13.0) + 0.5 - iGlobalTime * 0.2));
        v2 += dot(p, p) * 0.0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iGlobalTime * 0.3));
        v3 += length(p.xy * 10.0) * 0.0003;
        s += 0.035;
    }

    float len = length(uv);
    v1 *= lerp(0.7, 0.0, len);
    v2 *= lerp(0.5, 0.0, len);
    v3 *= lerp(0.9, 0.0, len);

    float3 col = float3(v3 * (1.5 + sin(iGlobalTime * 0.2) * 0.4), (v1 + v3) * 0.3, v2)
					+ lerp(0.2, 0.0, len) * 0.85
					+ lerp(0.0, 0.6, v3) * 0.3;

    float3 powered = pow(abs(col), float3(1.2, 1.2, 1.2));
    float3 minimized = min(powered, 1.0);
    float4 outputColor = float4(minimized, 1.0);

	//Since there are limitations on operations that can be done on certain formats when using compute shaders
	//I elected to go with the most flexible one (UINT 32bit) and do my packing manually to simulate an R8G8B8A8_UINT format.
	//There might be better ways to do this :)
	// uint r = outputColor.r * 255.0;
	// uint g = ((uint)(outputColor.g * 255.0)) << 8;
	// uint b = ((uint)(outputColor.b * 255.0)) << 16;
	// uint a = ((uint)(outputColor.a * 255.0)) << 24;
	//OutputSurface[ThreadId.xy] = r | g | b | a;
    OutputSurface[ThreadId.xy] = outputColor;

}




// Adds current sampled color and opacity to the accumulated LightEnergy
void AccumulateLightEnergy(inout float4 LightEnergy, in float4 CurrentSample)
{
    // Affect the color depending on how much opaque the current sample is and 
    // how strong the existing accumulated Light Energy is.
    LightEnergy.rgb = LightEnergy.rgb + (CurrentSample.rgb * CurrentSample.a *
                      (1.0 - LightEnergy.a));
    // Affect the accumulated light energy strength.
    LightEnergy.a = LightEnergy.a + (CurrentSample.a * (1.0 - LightEnergy.a));
}

// Samples a Data volume, transforms it to fit the TF Intensity domain and then 
// transforms it by the TF. Corrects the opacity to account for StepSize (in 
// World units).
float4 SampleDataVolume(float3 CurPos, float StepSize, Texture3D Volume, 
                        SamplerState VolumeSampler, Texture2D TF, 
                        SamplerState TFSampler, float2 TFIntensityDomain)
{
    float VolumeSample = Volume.SampleLevel(VolumeSampler, CurPos, 0).r;
    RemapIntensity(VolumeSample, TFIntensityDomain);

    float4 ColorSample = TF.SampleLevel(TFSampler, float2(VolumeSample, 0.5), 0);
    ColorSample.a = 1.0 - pow(1.0 - ColorSample.a, StepSize);
    return ColorSample;
}

// Samples a Label volume, gets the corresponding color and corrects the opacity
// to account for StepSize.
float4 SampleLabelVolume(float3 CurPos, float StepSize, Texture3D Volume)
{
    int x, y, z;
    Volume.GetDimensions(x, y, z);
    int3 Dimensions = int3(x - 1, y - 1, z - 1);
    // We don't want to interpolate here, use load instead of sample.
    float LabelValue = Volume.Load(int4(round(Dimensions * saturate(CurPos)), 0)).r;
    float4 Color = GetColorFromLabelValue(FloatToChar(LabelValue));
    Color.a = 1.0 - pow(1.0 - Color.a, StepSize);
    return Color;
}

// Performs one raymarch step and accumulates the result to the existing 
// Accumulated Light Energy.
void AccumulateOneRaymarchStep(inout float4 AccumulatedLightEnergy, float3 CurPos,
                               Texture3D DataVolume, SamplerState DataVolumeSampler,
                               Texture2D TF, SamplerState TFSampler, 
                               float2 TFIntensityDomain, Texture3D LightVolume, 
                               SamplerState LightVolumeSampler, float StepSize)
{
    // Sample intensity from the volume and get corresponding color-opacity from 
    // transfer function.
    float4 ColorSample = SampleDataVolume(CurPos, StepSize, DataVolume, 
                                          DataVolumeSampler, TF, TFSampler, 
                                          TFIntensityDomain);
    
    // Get lighting information from illumination volume for current position and
    // Multiply sampled color with light color to adjust intensity according to light 
    // strength.
    ColorSample.rgb = 
        ColorSample.rgb * LightVolume.SampleLevel(LightVolumeSampler, saturate(CurPos), 0).r;
        // Accumulate current colored sample to the final values.
    AccumulateLightEnergy(AccumulatedLightEnergy, ColorSample);
}

// Performs one raymarch step in a label volume and accumulates the result to the
// existing Accumulated Light Energy.
void AccumulateOneRaymarchLabelStep(inout float4 AccumulatedLightEnergy,
                    float3 CurPos, Texture3D LabelVolume, float StepSize)
{
    // Sample intensity from the volume and get corresponding color-opacity
    // from transfer function.
    float4 ColorSample = SampleLabelVolume(CurPos, StepSize, LabelVolume);
    // Accumulate colored label sample to the final values.
    AccumulateLightEnergy(AccumulatedLightEnergy, ColorSample);
}


// Performs lit raymarch for the current pixel. Also takes into account a provided labeling volume. 
// Labeling volume ignores the clipping plane, so labels are always visible.
// The lighting information is taken from a precomputed light volume.
float4 PerformLitRaymarchLabeled(Texture3D DataVolume, SamplerState DataVolumeSampler, // Data Volume and Sampler
                                 Texture2D TF, SamplerState TFSampler, float2 TFIntensityDomain, // Transfer func, sampler and intensity domain modifier
                                 Texture3D LightVolume, SamplerState LightVolumeSampler, // Light Volume
                                 Texture3D LabelVolume, // Label Volume
                                 float3 CurPos, float MaxSteps, float StepSize, float FinalStep, // Position of ray entry to cube, number of steps, size of a step and a 0-1 value of how big the final step is compared to regular steps 
                                 float3 ClippingCenter, float3 ClippingDirection, // Clipping plane position and direction of clipped away region
                                 FMaterialPixelParameters MaterialParameters)                    // Material Parameters
{
    // Get camera vector in local space and multiply it by step size.
    float3 LocalCamVec = normalize(mul(MaterialParameters.CameraVector, GetPrimitiveData(MaterialParameters.PrimitiveId).WorldToLocal)) * StepSize;
    // Get step size in world units to be consistent with compute shaders' opacity calculations.
    float StepSizeWorld = length(mul(LocalCamVec, GetPrimitiveData(MaterialParameters.PrimitiveId).LocalToWorld));
    // Initialize accumulated light energy.
    float4 LightEnergy = 0;
    // Jitter Entry position to avoid artifacts.
    JitterEntryPos(CurPos, LocalCamVec, MaterialParameters);

    int i = 0;
    for (i = 0; i < MaxSteps; i++)
    {
        // Label volume ignores clipping.
        AccumulateOneRaymarchLabelStep(LightEnergy, CurPos, LabelVolume, StepSizeWorld);
	    // Any position that is clipped by the clipping plane shall be ignored.
        if (!IsCurPosClipped(CurPos, ClippingCenter, ClippingDirection))
        {
            AccumulateOneRaymarchStep(LightEnergy, CurPos, DataVolume, DataVolumeSampler, TF, TFSampler, TFIntensityDomain, LightVolume, LightVolumeSampler, StepSizeWorld);
        }

        // Exit early if light energy (opacity) is already very high (so future steps would have almost no impact on color).
        if (LightEnergy.a > 0.99f)
        {
            LightEnergy.a = 1.0f;
            break;
        };
        CurPos -= LocalCamVec;
    }

    // Handle FinalStep (only if we went through all the previous steps and the final step size is above eps)
    if (i == MaxSteps && FinalStep > 0.01f)
    {
        CurPos -= LocalCamVec * (FinalStep);
        // Accumulate label.
        AccumulateOneRaymarchLabelStep(LightEnergy, CurPos, LabelVolume, StepSizeWorld * FinalStep);
        // If the final step is clipped, don't do anything.
        if (!IsCurPosClipped(CurPos, ClippingCenter, ClippingDirection))
        {
            AccumulateOneRaymarchStep(LightEnergy, CurPos, DataVolume, DataVolumeSampler, TF, TFSampler, TFIntensityDomain, LightVolume, LightVolumeSampler, StepSizeWorld * FinalStep);
        }
    }

    return LightEnergy;
}
