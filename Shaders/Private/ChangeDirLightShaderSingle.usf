#include "/Engine/Private/Common.ush"
#include "DirLightCommon.usf"

// Thx Temaran for original HLSL & usage example

RWTexture3D<float> ALightVolume;

RWTexture2D<float> WriteBuffer;
Texture2D ReadBuffer;

RWTexture2D<float> NewWriteBuffer;
Texture2D NewReadBuffer;

// Going from
// 0 = +X, 1 = -X, 2 = Y, 3 = -Y, 4 = Z, 5 = -Z
uint Axis;
uint Loop;

Texture3D Volume;

Texture2D TransferFunc;

float3 LightPosition;

float LightIntensity;


float3 LocalClippingCenter;
float3 LocalClippingDirection;

float2 TFIntensityDomain;

float3 NewLightPosition;

float NewLightIntensity;

float Weight;
float NewWeight;

// The shader code is common for all axes and always 2D in X and Y space
// If going along X - threadgroup X = Volume Y dimension, threadgroup Y = Volume Z dimension
// If going along Y - threadgroup X = Volume X dimension, threadgroup Y = Volume Z dimension
// If going along Z - threadgroup X = Volume X dimension, threadgroup Y = Volume Y dimension (the simple case)

SamplerState TransferFuncSampler;
SamplerState VolumeSampler;

// The buffer shall use a hard-set border color (the light outside the volume is not occluded by anything ->
// sampling outside means full original light.
SamplerState ReadBufferSampler;
SamplerState NewReadBufferSampler;

[numthreads(32, 32, 1)]
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{
	//Set up some variables we are going to need
    float sizeX, sizeY, sizeZ;
    ALightVolume.GetDimensions(sizeX, sizeY, sizeZ);
	float3 iResolution = float3(sizeX, sizeY, sizeZ);
    uint3 uResolution = uint3(sizeX, sizeY, sizeZ);

    float texSizeX, texSizeY;
    WriteBuffer.GetDimensions(texSizeX, texSizeY);

    float cursample = 0;
    float colorsample = 0;
	
    float2 pixelLoc = ThreadId.xy;
    int3 pos = GetPos(pixelLoc, uResolution, Loop, Axis);
    float oldAlpha = ALightVolume[pos];

	if (Loop == 0)
    {
		// Subtract old light, add new light. No occlusion or anything.
        float removedColor = ReadBuffer.SampleLevel(ReadBufferSampler, float2(-1, -1), 0);
        float addedColor = NewReadBuffer.SampleLevel(NewReadBufferSampler, float2(-1, -1), 0);
                
        WriteBuffer[pixelLoc] = removedColor;
        NewWriteBuffer[pixelLoc] = addedColor;

        ALightVolume[pos] = oldAlpha - removedColor + addedColor;
    }
    else
    {
		// TODO! Set pix offset as a uniform. EVEN better : Save it in UV offset!
		// + (0.5, 0.5) to sample the centers of pixels!
        float2 prevXY = pixelLoc+ float2(0.5, 0.5) + GetPixOffset(LightPosition, Axis);
        float2 prevUV = (prevXY) / float2(texSizeX, texSizeY);
        float previousRemovedLightColor = ReadBuffer.SampleLevel(ReadBufferSampler, prevUV, 0);

        prevXY = pixelLoc+ float2(0.5, 0.5) + GetPixOffset(NewLightPosition, Axis);
        prevUV = (prevXY) / float2(texSizeX, texSizeY);
        float previousAddedLightColor = NewReadBuffer.SampleLevel(NewReadBufferSampler, prevUV, 0);
  
        float3 uvw = GetUVW(pos, iResolution);

        // Ignore clipped.
        if (dot(uvw - LocalClippingCenter, LocalClippingDirection) < 0)
        {
            colorsample = 0;
        } 
        else
        {
            cursample = Volume.SampleLevel(VolumeSampler, GetUVW(pos, iResolution), 0);
		    // Get Color&alpha from intensity
            cursample = RemapIntensity(cursample, TFIntensityDomain);
            colorsample = TransferFunc.SampleLevel(TransferFuncSampler, float2(cursample, 0.5f), 0).a;
        }

        float removedAlpha = previousRemovedLightColor * (1 - (colorsample));
        float addedAlpha = previousAddedLightColor * (1 - (colorsample));

        WriteBuffer[pixelLoc] = removedAlpha;
        NewWriteBuffer[pixelLoc] = addedAlpha;

        ALightVolume[pos] = oldAlpha - removedAlpha + addedAlpha;
    }
}